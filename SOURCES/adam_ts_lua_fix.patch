diff --git a/plugins/experimental/ts_lua/ts_lua_server_request.c b/plugins/experimental/ts_lua/ts_lua_server_request.c
index 1a90166..7ba6995 100644
--- a/plugins/experimental/ts_lua/ts_lua_server_request.c
+++ b/plugins/experimental/ts_lua/ts_lua_server_request.c
@@ -71,6 +71,7 @@ static int ts_lua_server_request_set_url_scheme(lua_State *L);
 static int ts_lua_server_request_server_addr_get_ip(lua_State *L);
 static int ts_lua_server_request_server_addr_get_port(lua_State *L);
 static int ts_lua_server_request_server_addr_get_addr(lua_State *L);
+static int ts_lua_server_request_server_addr_set_addr(lua_State *L);
 static int ts_lua_server_request_server_addr_get_outgoing_port(lua_State *L);
 
 void
@@ -113,10 +114,19 @@ ts_lua_inject_server_request_server_addr_api(lua_State *L)
   lua_pushcfunction(L, ts_lua_server_request_server_addr_get_addr);
   lua_setfield(L, -2, "get_addr");
 
+  lua_pushcfunction(L, ts_lua_server_request_server_addr_set_addr);
+  lua_setfield(L, -2, "set_addr");
+
   lua_pushcfunction(L, ts_lua_server_request_server_addr_get_outgoing_port);
   lua_setfield(L, -2, "get_outgoing_port");
 
   lua_setfield(L, -2, "server_addr");
+
+  lua_pushinteger(L, AF_INET);
+  lua_setglobal(L, "TS_LUA_AF_INET");
+
+  lua_pushinteger(L, AF_INET6);
+  lua_setglobal(L, "TS_LUA_AF_INET6");
 }
 
 static void
@@ -143,8 +153,9 @@ ts_lua_server_request_header_get(lua_State *L)
   const char *val;
   int val_len;
   size_t key_len;
+  int count;
 
-  TSMLoc field_loc;
+  TSMLoc field_loc, next_field_loc;
   ts_lua_http_ctx *http_ctx;
 
   GET_HTTP_CONTEXT(http_ctx, L);
@@ -161,11 +172,23 @@ ts_lua_server_request_header_get(lua_State *L)
 
   if (key && key_len) {
     field_loc = TSMimeHdrFieldFind(http_ctx->server_request_bufp, http_ctx->server_request_hdrp, key, key_len);
-    if (field_loc) {
-      val = TSMimeHdrFieldValueStringGet(http_ctx->server_request_bufp, http_ctx->server_request_hdrp, field_loc, -1, &val_len);
-      lua_pushlstring(L, val, val_len);
-      TSHandleMLocRelease(http_ctx->server_request_bufp, http_ctx->server_request_hdrp, field_loc);
 
+    if (field_loc != TS_NULL_MLOC) {
+      count = 0;
+      while (field_loc != TS_NULL_MLOC) {
+        val = TSMimeHdrFieldValueStringGet(http_ctx->server_request_bufp, http_ctx->server_request_hdrp, field_loc, -1, &val_len);
+        next_field_loc = TSMimeHdrFieldNextDup(http_ctx->server_request_bufp, http_ctx->server_request_hdrp, field_loc);
+        lua_pushlstring(L, val, val_len);
+        count++;
+        // multiple headers with the same name must be semantically the same as one value which is comma seperated
+        if (next_field_loc != TS_NULL_MLOC) {
+          lua_pushlstring(L, ",", 1);
+          count++;
+        }
+        TSHandleMLocRelease(http_ctx->server_request_bufp, http_ctx->server_request_hdrp, field_loc);
+        field_loc = next_field_loc;
+      }
+      lua_concat(L, count);
     } else {
       lua_pushnil(L);
     }
@@ -185,8 +208,9 @@ ts_lua_server_request_header_set(lua_State *L)
   size_t val_len;
   size_t key_len;
   int remove;
+  int first;
 
-  TSMLoc field_loc;
+  TSMLoc field_loc, tmp;
 
   ts_lua_http_ctx *http_ctx;
 
@@ -212,13 +236,25 @@ ts_lua_server_request_header_set(lua_State *L)
   field_loc = TSMimeHdrFieldFind(http_ctx->server_request_bufp, http_ctx->server_request_hdrp, key, key_len);
 
   if (remove) {
-    if (field_loc) {
+    while (field_loc != TS_NULL_MLOC) {
+      tmp = TSMimeHdrFieldNextDup(http_ctx->server_request_bufp, http_ctx->server_request_hdrp, field_loc);
       TSMimeHdrFieldDestroy(http_ctx->server_request_bufp, http_ctx->server_request_hdrp, field_loc);
+      TSHandleMLocRelease(http_ctx->server_request_bufp, http_ctx->server_request_hdrp, field_loc);
+      field_loc = tmp;
+    }
+  } else if (field_loc != TS_NULL_MLOC) {
+    first = 1;
+    while (field_loc != TS_NULL_MLOC) {
+      tmp = TSMimeHdrFieldNextDup(http_ctx->server_request_bufp, http_ctx->server_request_hdrp, field_loc);
+      if (first) {
+        first = 0;
+        TSMimeHdrFieldValueStringSet(http_ctx->server_request_bufp, http_ctx->server_request_hdrp, field_loc, -1, val, val_len);
+      } else {
+        TSMimeHdrFieldDestroy(http_ctx->server_request_bufp, http_ctx->server_request_hdrp, field_loc);
+      }
+      TSHandleMLocRelease(http_ctx->server_request_bufp, http_ctx->server_request_hdrp, field_loc);
+      field_loc = tmp;
     }
-
-  } else if (field_loc) {
-    TSMimeHdrFieldValueStringSet(http_ctx->server_request_bufp, http_ctx->server_request_hdrp, field_loc, -1, val, val_len);
-
   } else if (TSMimeHdrFieldCreateNamed(http_ctx->server_request_bufp, http_ctx->server_request_hdrp, key, key_len, &field_loc) !=
              TS_SUCCESS) {
     TSError("[ts_lua][%s] TSMimeHdrFieldCreateNamed error", __FUNCTION__);
@@ -229,8 +265,9 @@ ts_lua_server_request_header_set(lua_State *L)
     TSMimeHdrFieldAppend(http_ctx->server_request_bufp, http_ctx->server_request_hdrp, field_loc);
   }
 
-  if (field_loc)
+  if (field_loc != TS_NULL_MLOC) {
     TSHandleMLocRelease(http_ctx->server_request_bufp, http_ctx->server_request_hdrp, field_loc);
+  }
 
   return 0;
 }
@@ -251,6 +288,8 @@ ts_lua_server_request_get_headers(lua_State *L)
   int value_len;
   TSMLoc field_loc;
   TSMLoc next_field_loc;
+  const char *tvalue;
+  size_t tvalue_len;
 
   ts_lua_http_ctx *http_ctx;
 
@@ -262,13 +301,33 @@ ts_lua_server_request_get_headers(lua_State *L)
 
   field_loc = TSMimeHdrFieldGet(http_ctx->server_request_bufp, http_ctx->server_request_hdrp, 0);
 
-  while (field_loc) {
+  while (field_loc != TS_NULL_MLOC) {
     name = TSMimeHdrFieldNameGet(http_ctx->server_request_bufp, http_ctx->server_request_hdrp, field_loc, &name_len);
     if (name && name_len) {
-      value = TSMimeHdrFieldValueStringGet(http_ctx->server_request_bufp, http_ctx->server_request_hdrp, field_loc, -1, &value_len);
+      // retrieve the header name from table
       lua_pushlstring(L, name, name_len);
-      lua_pushlstring(L, value, value_len);
-      lua_rawset(L, -3);
+      lua_gettable(L, -2);
+      if (lua_isnil(L, -1)) {
+        // if header name does not exist in the table, insert it
+        lua_pop(L, 1);
+        value =
+          TSMimeHdrFieldValueStringGet(http_ctx->server_request_bufp, http_ctx->server_request_hdrp, field_loc, -1, &value_len);
+        lua_pushlstring(L, name, name_len);
+        lua_pushlstring(L, value, value_len);
+        lua_rawset(L, -3);
+      } else {
+        // if header name exists in the table, append a command and the new value to the end of the existing value
+        tvalue = lua_tolstring(L, -1, &tvalue_len);
+        lua_pop(L, 1);
+        value =
+          TSMimeHdrFieldValueStringGet(http_ctx->server_request_bufp, http_ctx->server_request_hdrp, field_loc, -1, &value_len);
+        lua_pushlstring(L, name, name_len);
+        lua_pushlstring(L, tvalue, tvalue_len);
+        lua_pushlstring(L, ",", 1);
+        lua_pushlstring(L, value, value_len);
+        lua_concat(L, 3);
+        lua_rawset(L, -3);
+      }
     }
 
     next_field_loc = TSMimeHdrFieldNext(http_ctx->server_request_bufp, http_ctx->server_request_hdrp, field_loc);
@@ -711,3 +770,49 @@ ts_lua_server_request_server_addr_get_addr(lua_State *L)
 
   return 3;
 }
+
+static int
+ts_lua_server_request_server_addr_set_addr(lua_State *L)
+{
+  union {
+    struct sockaddr_in sin4;
+    struct sockaddr_in6 sin6;
+    struct sockaddr sa;
+  } addr;
+  ts_lua_http_ctx *http_ctx;
+  int n;
+  int port;
+  int family;
+  const char *sip;
+  size_t sip_len;
+
+  GET_HTTP_CONTEXT(http_ctx, L);
+
+  n = lua_gettop(L);
+
+  if (n == 3) {
+    sip    = luaL_checklstring(L, 1, &sip_len);
+    port   = luaL_checknumber(L, 2);
+    family = luaL_checknumber(L, 3);
+
+    if (family == AF_INET) {
+      addr.sin4.sin_family = AF_INET;
+      addr.sin4.sin_port   = htons(port);
+      if (!inet_pton(family, sip, &addr.sin4.sin_addr)) {
+        return luaL_error(L, "invalid ipv4 address");
+      }
+    } else {
+      addr.sin6.sin6_family = AF_INET6;
+      addr.sin6.sin6_port   = htons(port);
+      if (!inet_pton(family, sip, &addr.sin6.sin6_addr)) {
+        return luaL_error(L, "invalid ipv6 address");
+      }
+    }
+
+    TSHttpTxnServerAddrSet(http_ctx->txnp, &addr.sa);
+  } else {
+    return luaL_error(L, "incorrect # of arguments to ts.server_request.addr.set_addr, receiving %d instead of 3", n);
+  }
+
+  return 0;
+}
